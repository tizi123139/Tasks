# 第五阶段学习笔记

---



## 1.go的前世今生

Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。该项目的三位领导者均是著名的 IT 工程师：Robert Griesemer，参与开发 Java HotSpot 虚拟机；Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。自 2008 年 1 月起，Ken Thompson 就开始研发一款以 C 语言为目标结果的编译器来拓展 Go 语言的设计思想。

Go语言有时候被描述为“类C语言”，或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。

特性：简洁、快速、安全、并行、有趣、开源、内存管理、数组安全

用途：Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言，有着更高的开发效率

---



## 2.搭建环境

---



## 3.go的执行原理

Go的执行原理主要包括编译和运行两个阶段。

在编译阶段，Go源代码会经过编译器转换成与平台相关的机器码，生成可执行文件。Go编译器会将Go代码转换成中间代码，然后再生成对应的机器码，这样可以实现跨平台的兼容性。Go的编译过程相对较快，使得开发者可以快速得到可执行文件。

在运行阶段，Go程序会被操作系统加载到内存中，并在操作系统上运行。Go语言的运行时系统（runtime）负责管理内存分配、垃圾回收、并发等操作。Go通过goroutines实现轻量级的并发，它们由Go的运行时系统进行调度，而不是依赖于操作系统的线程。这使得Go程序在处理并发任务时非常高效，并且可以更好地利用多核处理器。



### go的命令

go build: 编译Go程序并生成可执行文件。

go run: 编译并运行Go程序。

go install: 编译并安装Go程序，将可执行文件安装到$GOPATH/bin目录下。

go get: 下载并安装指定的包和依赖。

go test: 运行Go程序中的测试文件。

go fmt: 格式化Go代码，使其符合Go语言的风格规范。

go vet: 静态代码分析工具，用于检查Go代码中的潜在错误。

go mod: Go语言的模块管理工具，用于管理依赖关系。

go doc: 查看Go代码的文档。

---



## 4.go的基础语法

### （1）注释

单行注释：//

多行注释：/*

### （2）数据类型

基本数据类型：数值型：整数，浮点   ，字符型，布尔型，字符串

复杂数据类型：指针，数组，结构体，函数，切片，接口，map               

### （3）类型转换

### （4）变量

变量的声明：var age int

变量的赋值：age=18

变量的使用：fmt.Println("age = ",age)

声明和赋值可以合成一句：var age int = 19

### （5）常量

### （6）运算符、表达式

算术运算符：+，-，*，/，%，++，--

赋值运算符：=，+=，-=等

关系运算符：==，！=，>，<等，关系运算符的结果都是bool型，为true或false

### （7）输入输出

输入：方式一：Scanln

```
var age int

fmt.Scanln(&age)

```

方式二：Scanf

```
fmt.Scanf("%d %s %f",&age,&name,&score)
```



### （8）分支逻辑

### （9）循环逻辑

### （10）数组

定义：var score [5]int

初始化：

```
var arr [3]int = [3]int{3,6,9}

var arr = [3]int{1,4,7}

var arr = [...]int
```



### （11）切片

切片构建在数组上

```
var intarr [6]int =[6]int{3,6,4,2,3,7}
var slice []int =intarr[1:3]        
slice := intarr[1:3]  //  切出的一段片段，从1 到3 ，不包括3
```

​      

切片可以动态增长：

```
slice1 = append(slice,88,50)
```

切片的拷贝：

```
var a []int = []int{1,4,7}

vae b []int = make([]int,10)

copy(b,a)
```



### （12）函数

函数命名首字母不能为数字

参数数量可变：func test (args...int)

基本数据类型和数组默认是值传递

### （13）指针

指针就是内存地址

定义指针变量：

```
var ptr *int = &age   // ptr是指针变量的名字
```

 

获取ptr这个指针或者这个地址指向的数据：

```
fmt.Printf("%v",*ptr)
```



### （14）包管理

package进行包的声明

函数调用时前面要定位到所在的包

首字母大写，函数和变量才可以被其他包访问.

一个目录下的同级文件归属一个包

同一个包不可以定义重名的函数

### （15）结构体



### （16）map

可以通过键key来获取对应的值value

var map变量名 map[keytype]valuetype

key通常为int ,string   value通常为数字,string,map

slice,map,function不可以为key

定义map变量：

```
var a map[int]string
```

只声明map内存没有分配空间，必须通过make函数进行初始化

```
a=make(map[int]string,10)   //map可以存放10个键值对
a[20095]="张三"   //将键值对存入map中
```

或者直接

```
b := make(map[int]string)  //默认分配1个内存
c := map[int]string{
     2005 : "张三"
     2006 : "李四"
}
c[2007] = "王五"
```

key-value是无序的

key不能重复，如果重复，后一个value会替换前一个

value可以重复

map的操作：

- 增加和更新

key没有就是增加，key存在就是修改

```
c[2007] = "王五"
```

- 删除

```
delete(map,"key")
delete(c,2007)
```

- 清空

遍历key，依次删除

或者map = make(),make一个新的

- 查找

```
value,bool = map[key] //bool为是否返回，true或false

value,flag := b[2005]
```

- 获取长度

len函数 

```
fmt.Println(len(b))
```

- 遍历

```
for k,v := range b {

fmt.Printf("%v %v",k,v)

}
```



---

